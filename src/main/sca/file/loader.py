from math import ceil
from joblib import Parallel, delayed
import numpy as np

from aidenv.api.loader import FileLoader

from sca.file.params import TRACE_SIZE

class TraceLoader(FileLoader):
    '''
    Abstract loader of encryption power traces (and their plain texts) from a
    raw file batched by random plain texts used in the chipering.
    '''

    def build_file_id(self, *args):
        '''
        Build a raw file identifier.
        args: arguments of the identifier
        '''
        raise NotImplementedError

    def build_file_path(self, file_id):
        '''
        Build a raw file path.
        file_id: identifier of the file
        '''
        raise NotImplementedError

    def load_all_traces(self, file_path):
        '''
        Load the whole full traces (with plain texts + key) from a raw file.
        file_path: path of the file
        '''
        raise NotImplementedError

    def load_some_traces(self, file_path, plain_indices):
        '''
        Load some full traces (with plain texts + key) from a raw file.
        file_path: path of the file
        plain_indices: plain text indices of a file
        '''
        raise NotImplementedError

    def load_some_projected_traces(self, file_path, plain_indices, time_indices):
        '''
        Load some temporal projected traces (with plain texts + key) from a raw file.
        file_path: path of the file
        plain_indices: plain text indices of a file
        time_indices: temporal indices of a trace
        '''
        raise NotImplementedError

    def fetch_traces(self, file_path, plain_indices):
        '''
        Load some traces by prior specification of desired length.
        file_path: path of the file
        plain_indices: plain text indices of a file
        '''
        raise NotImplementedError

class OurTraceLoader(TraceLoader):
    '''
    Abstract loader from raw file of power traces generated by our encryption technology.
    '''
    
    HEADER_SIZE = 26

    INVALID_FILE_CHANN_TYPE = lambda f : f'file {f} has invalid channel type'
    INVALID_PLAIN_INDICES_MSG = 'invalid plain text indices'
    INVALID_TIME_INDICES_MSG = 'invalid temporal indices'

    def __init__(self, trace_len=None):
        '''
        Create new trace loader.
        trace_len: desired length of a trace loaded from fetch method
        '''
        if trace_len is None:
            self.trace_len = TRACE_SIZE
            self.desired_time_idx = None
        else:
            self.trace_len = trace_len
            self.desired_time_idx = np.arange(0, trace_len)

    def read_file_base(self, file_path):
        ''''
        Read basic info of a raw file.
        file_path: path of the file
        '''
        with open(file_path, 'rb') as f:
            num_traces = int.from_bytes(f.read(4), byteorder='little', signed=False)
            trace_size = int.from_bytes(f.read(4), byteorder='little', signed=False)
            channel_type = f.read(1).decode("ascii")
            text_len = int.from_bytes(f.read(1), byteorder='little', signed=False)
            
            if (channel_type=='f'):
                channel_dtype=np.dtype('float32')
            elif (self.channel_type=='d'):
                channel_dtype=np.dtype('float64')
            else:
                raise RuntimeError(OurTraceLoader.INVALID_FILE_CHANN_TYPE(file_path))
            
            row_len = text_len + trace_size*channel_dtype.itemsize
            key = np.frombuffer(buffer=f.read(16), dtype='uint8');

            return num_traces, trace_size, text_len, channel_dtype, row_len, key

    def validate_trace_indices(self, num_traces, plain_indices):
        '''
        Check consistency of some trace indices.
        plain_indices: plain text indices of a file
        '''
        if np.all(plain_indices < 0) or np.all(plain_indices >= num_traces):
            raise IndexError(OurTraceLoader.INVALID_PLAIN_INDICES_MSG)

    def validate_time_indices(self, trace_size, time_indices):
        '''
        Check consistency of some time indices.
        time_indices: temporal indices of a trace
        '''
        if np.all(time_indices < 0) or np.all(time_indices >= trace_size):
            raise IndexError(OurTraceLoader.INVALID_TIME_INDICES_MSG)
    
    def load_all_traces(self, file_path):
        num_traces, trace_size, text_len, channel_dtype, row_len, key = self.read_file_base(file_path)

        with open(file_path, 'rb') as f:
            f.seek(OurTraceLoader.HEADER_SIZE, 0)
            
            plain_texts = np.zeros((num_traces, text_len), dtype= 'uint8');
            traces = np.zeros((num_traces, trace_size), dtype= channel_dtype);
            
            for i in np.arange(0, num_traces):
                traces[i,:] = np.frombuffer(buffer=f.read(trace_size*channel_dtype.itemsize), dtype=channel_dtype)
                plain_texts[i,:] = np.frombuffer(buffer=f.read(text_len* plain_texts.itemsize), dtype=plain_texts.dtype)
            
        return traces, plain_texts, key

    def load_some_traces(self, file_path, plain_indices):
        num_traces, trace_size, text_len, channel_dtype, row_len, key = self.read_file_base(file_path)

        idx = np.array(plain_indices)
        self.validate_trace_indices(num_traces, idx)
        n = len(idx)

        with open(file_path,'rb') as f:
            plain_texts = np.zeros((n, text_len), dtype='uint8');
            traces = np.zeros((n, trace_size), dtype=channel_dtype);
            j = 0

            for i in idx:
                f.seek(OurTraceLoader.HEADER_SIZE + row_len*i, 0)
                traces[j,:] = np.frombuffer(buffer=f.read(trace_size*channel_dtype.itemsize), dtype=channel_dtype)
                plain_texts[j,:] = np.frombuffer(buffer=f.read(text_len*plain_texts.itemsize), dtype=plain_texts.dtype)
                j = j + 1

        return traces, plain_texts, key
    
    def load_some_projected_traces(self, file_path, plain_indices, time_indices):
        num_traces, trace_size, text_len, channel_dtype, row_len, key = self.read_file_base(file_path)

        trace_idx = np.array(plain_indices).reshape((len(plain_indices),1))
        self.validate_trace_indices(num_traces, trace_idx)
        trace_len = len(plain_indices)

        time_idx = np.array(time_indices)
        self.validate_time_indices(trace_size, time_idx)
        time_len = len(time_indices)
        
        with open(file_path,'rb') as f:
            traces = np.zeros((trace_len, time_len), dtype=channel_dtype)
            plain_texts = np.zeros((trace_len, text_len), dtype= 'uint8')
            
            pos = OurTraceLoader.HEADER_SIZE + trace_idx*row_len + time_idx*channel_dtype.itemsize
            
            for i in range(pos.shape[0]):
                for j in range(pos.shape[1]):
                    f.seek(pos[i][j], 0)
                    traces[i,j] =  np.frombuffer(buffer=f.read(channel_dtype.itemsize), dtype=channel_dtype)
                
                f.seek(OurTraceLoader.HEADER_SIZE + row_len* plain_indices[i] + trace_size*channel_dtype.itemsize , 0)
                plain_texts[i,:] = np.frombuffer(buffer=f.read(text_len* plain_texts.itemsize), dtype=plain_texts.dtype)
        
        return traces, plain_texts, key

    def fetch_traces(self, file_path, plain_indices):
        '''
        Load some traces by prior specification of desired length.
        file_path: path of the file
        plain_indices: plain text indices of a file
        '''
        if self.desired_time_idx is None:
            return self.load_some_traces(file_path, plain_indices)
        else:
            return self.load_some_projected_traces(file_path, plain_indices,
                                                    self.desired_time_idx)

class ParallelTraceLoader:
    '''
    Trace loader wrapper for parallel mode.
    '''

    def __init__(self, loader, num_workers, workers_type):
        '''
        Create new parallel trace loader.
        loader: power trace loader
        '''
        self.loader = loader
        self.num_workers = num_workers
        self.workers_type = workers_type

    def build_file_id(self, *args):
        return self.loader.build_file_id(*args)

    def build_file_path(self, file_id):
        return self.loader.build_file_path(file_id)

    def fetch_trace_parallel(self, voltage, frequency, key_value, plain_indices):
        file_id = self.loader.build_file_id(voltage, frequency, key_value)
        file_path = self.loader.build_file_path(file_id)
        traces, plain_text, key_val = self.loader.fetch_traces(file_path, plain_indices)
        return plain_indices, traces, plain_text, key_val

    def fetch_traces(self, voltage, frequency, key_value, plain_indices):
        worker_indices = []
        chunk_size = ceil(len(plain_indices) / self.num_workers)
        for i in range(self.num_workers):
            low_idx = i*chunk_size
            high_idx = min(low_idx+chunk_size, len(plain_indices))
            worker_indices.append(plain_indices[low_idx:high_idx])

        data = Parallel(n_jobs=self.num_workers, prefer=self.workers_type) (delayed(self.fetch_trace_parallel) \
                        (voltage, frequency, key_value, worker_chunk) for worker_chunk in worker_indices)
        return data
