import numpy as np

from aidenv.api.loader import FileLoader

class TraceLoader(FileLoader):
    '''
    Abstract loader of encryption power traces (and their plain texts) from a
    raw file batched by random plain texts used in the chipering.
    '''

    def build_file_id(self, *args):
        '''
        Build a raw file identifier.
        args: arguments of the identifier
        '''
        raise NotImplementedError

    def build_file_path(self, file_id):
        '''
        Build a raw file path.
        file_id: identifier of the file
        '''
        raise NotImplementedError

    def load_all_traces(self, file_path):
        '''
        Load the whole full traces (and their plain texts) from a raw file.
        file_path: path of the file
        '''
        raise NotImplementedError

    def load_some_traces(self, file_path, plain_indices):
        '''
        Load some full traces (and their plain texts) from a raw file.
        file_path: path of the file
        plain_indices: plain text indices of a file
        '''
        raise NotImplementedError

    def load_some_projected_traces(self, file_path, plain_indices, time_indices):
        '''
        Load some temporal projected traces (and their plain texts) from a raw file.
        file_path: path of the file
        plain_indices: plain text indices of a file
        time_indices: temporal indices of a trace
        '''
        raise NotImplementedError

class OurTraceLoader(TraceLoader):
    '''
    Abstract loader from raw file of power traces generated by our encryption technology.
    '''
    
    HEADER_SIZE = 26

    INVALID_FILE_CHANN_TYPE = lambda f : 'file {f} has invalid channel type'
    INVALID_PLAIN_INDICES_MSG = 'invalid plain text indices'
    INVALID_TIME_INDICES_MSG = 'invalid temporal indices'

    def read_file_base(self, file_path):
        ''''
        Read basic info of a raw file.
        file_path: path of the file
        '''
        with open(file_path, 'rb') as f:
            num_traces = int.from_bytes(f.read(4), byteorder='little', signed=False)
            trace_size = int.from_bytes(f.read(4), byteorder='little', signed=False)
            channel_type = f.read(1).decode("ascii")
            text_len = int.from_bytes(f.read(1), byteorder='little', signed=False)
            
            if (channel_type=='f'):
                channel_dtype=np.dtype('float32')
            elif (self.channel_type=='d'):
                channel_dtype=np.dtype('float64')
            else:
                raise RuntimeError(OurTraceLoader.INVALID_FILE_CHANN_TYPE(file_path))
            
            row_len = text_len + trace_size*channel_dtype.itemsize
            key = np.frombuffer(buffer=f.read(16), dtype='uint8');

            return num_traces, trace_size, text_len, channel_dtype, row_len, key

    def validate_trace_indices(self, num_traces, plain_indices):
        '''
        Check consistency of some trace indices.
        plain_indices: plain text indices of a file
        '''
        if np.all(plain_indices < 0) or np.all(plain_indices >= num_traces):
            raise IndexError(OurTraceLoader.INVALID_PLAIN_INDICES_MSG)

    def validate_time_indices(self, trace_size, time_indices):
        '''
        Check consistency of some time indices.
        time_indices: temporal indices of a trace
        '''
        if np.all(time_indices < 0) or np.all(time_indices >= trace_size):
            raise IndexError(OurTraceLoader.INVALID_TIME_INDICES_MSG)
    
    def load_all_traces(self, file_path):
        num_traces, trace_size, text_len, channel_dtype, row_len, key = self.read_file_base(file_path)

        with open(file_path, 'rb') as f:
            f.seek(OurTraceLoader.HEADER_SIZE, 0)
            
            plain_texts = np.zeros((num_traces, text_len), dtype= 'uint8');
            traces = np.zeros((num_traces, trace_size), dtype= channel_dtype);
            
            for i in np.arange(0, num_traces):
                traces[i,:] = np.frombuffer(buffer=f.read(trace_size*channel_dtype.itemsize), dtype=channel_dtype)
                plain_texts[i,:] = np.frombuffer(buffer=f.read(text_len* plain_texts.itemsize), dtype=plain_texts.dtype)
            
        return traces, plain_texts

    def load_some_traces(self, file_path, plain_indices):
        num_traces, trace_size, text_len, channel_dtype, row_len, _ = self.read_file_base(file_path)

        idx = np.array(plain_indices)
        self.validate_trace_indices(num_traces, idx)
        n = len(idx)

        with open(file_path,'rb') as f:
            plain_texts = np.zeros((n, text_len), dtype='uint8');
            traces = np.zeros((n, trace_size), dtype=channel_dtype);
            j = 0

            for i in idx:
                f.seek(OurTraceLoader.HEADER_SIZE + row_len*i, 0)
                traces[j,:] = np.frombuffer(buffer=f.read(trace_size*channel_dtype.itemsize), dtype=channel_dtype)
                plain_texts[j,:] = np.frombuffer(buffer=f.read(text_len*plain_texts.itemsize), dtype=plain_texts.dtype)
                j = j + 1

        return traces, plain_texts
    
    def load_some_projected_traces(self, file_path, plain_indices, time_indices):
        num_traces, trace_size, text_len, channel_dtype, row_len, key = self.read_file_base(file_path)

        trace_idx = np.array(plain_indices).reshape((len(plain_indices),1))
        self.validate_trace_indices(num_traces, trace_idx)
        trace_len = len(plain_indices)

        time_idx = np.array(time_indices)
        self.validate_time_indices(trace_size, time_idx)
        time_len = len(time_indices)
        
        with open(file_path,'rb') as f:
            traces = np.zeros((trace_len, time_len), dtype=channel_dtype)
            plain_texts = np.zeros((trace_len, text_len), dtype= 'uint8')
            
            pos = OurTraceLoader.HEADER_SIZE + trace_idx*row_len + time_idx*channel_dtype.itemsize
            
            for i in range(pos.shape[0]):
                for j in range(pos.shape[1]):
                    f.seek(pos[i][j], 0)
                    traces[i,j] =  np.frombuffer(buffer=f.read(channel_dtype.itemsize), dtype=channel_dtype)
                
                f.seek(OurTraceLoader.HEADER_SIZE + row_len* plain_indices[i] + trace_size*channel_dtype.itemsize , 0)
                plain_texts[i,:] = np.frombuffer(buffer=f.read(text_len* plain_texts.itemsize), dtype=plain_texts.dtype)
        
        return traces, plain_texts