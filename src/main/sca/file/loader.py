import numpy as np

from aidenv.api.loader import FileLoader

class TraceLoader(FileLoader):
    '''
    Abstract loader of encryption power traces (and their plain texts) from a
    raw file batched by random plain texts used in the chipering.
    '''

    def load_all_traces(self):
        '''
        Load the whole full traces (and their plain texts) from a raw file.
        '''
        raise NotImplementedError

    def load_some_traces(self, plain_indices):
        '''
        Load some full traces (and their plain texts) from a raw file.
        plain_indices: plain text indices of a file
        '''
        raise NotImplementedError

    def load_some_projected_traces(self, plain_indices, time_indices):
        '''
        Load some temporal projected traces (and their plain texts) from a raw file.
        plain_indices: plain text indices of a file
        time_indices: temporal indices of a trace
        '''
        raise NotImplementedError

class OurTraceLoader(TraceLoader):
    '''
    Loader from raw file of power traces generated by our encryption technology.
    '''
    
    HEADER_SIZE = 26

    NO_FILE_MSG = 'no file path has been specified'
    INVALID_PLAIN_INDICES_MSG = 'invalid plain text indices'
    INVALID_TIME_INDICES_MSG = 'invalid temporal indices'

    def __init__(self, file_path):
        '''
        Create our loader of traces.
        file_path: file path
        '''
        self.set_file_path(file_path)

    def set_file_path(self, file_path):
        self.file_path = file_path
        if self.file_path is None:
            self.num_traces = None
            self.trace_size = None
            self.channel_type = None
            self.text_len = None
            self.channel_dtype = None
            self.row_len = None
            self.key = None
            return

        with open(self.file_path,'rb') as infile:
            self.num_traces = int.from_bytes(infile.read(4), byteorder='little', signed=False)
            self.trace_size = int.from_bytes(infile.read(4), byteorder='little', signed=False)
            self.channel_type = infile.read(1).decode("ascii")
            self.text_len = int.from_bytes(infile.read(1), byteorder='little', signed=False)
            
            if (self.channel_type=='f'):
                self.channel_dtype=np.dtype('float32')
            elif (self.channel_type=='d'):
                self.channel_dtype=np.dtype('float64')
            else:
                assert(False)
            
            self.row_len = self.text_len + self.trace_size*self.channel_dtype.itemsize
            self.key = np.frombuffer(buffer=infile.read(16), dtype='uint8');

    def validate_trace_indices(self, plain_indices):
        '''
        Check consistency of some trace indices.
        plain_indices: plain text indices of a file
        '''
        if np.all(plain_indices < 0) or np.all(plain_indices >= self.num_traces):
            raise IndexError(OurTraceLoader.INVALID_PLAIN_INDICES_MSG)

    def validate_time_indices(self, time_indices):
        '''
        Check consistency of some time indices.
        time_indices: temporal indices of a trace
        '''
        if np.all(time_indices < 0) or np.all(time_indices >= self.trace_size):
            raise IndexError(OurTraceLoader.INVALID_TIME_INDICES_MSG)
    
    def load_all_traces(self):
        if self.file_path is None:
            raise ValueError(OurTraceLoader.NO_FILE_MSG)

        with open(self.file_path,'rb') as infile:
            infile.seek(OurTraceLoader.HEADER_SIZE, 0)
            
            plain_texts = np.zeros((self.num_traces, self.text_len), dtype= 'uint8');
            traces = np.zeros((self.num_traces, self.trace_size), dtype= self.channel_dtype);
            
            for i in np.arange(0, self.num_traces):
                traces[i,:] = np.frombuffer(buffer=infile.read(self.trace_size* self.channel_dtype.itemsize), dtype= self.channel_dtype)
                plain_texts[i,:] = np.frombuffer(buffer=infile.read(self.text_len* plain_texts.itemsize), dtype=plain_texts.dtype)
            
        return traces, plain_texts

    def load_some_traces(self, trace_indices):
        if self.file_path is None:
            raise ValueError(OurTraceLoader.NO_FILE_MSG)

        idx = np.array(trace_indices)
        self.validate_trace_indices(idx)

        n = len(idx)

        with open(self.file_path,'rb') as infile:
            plain_texts = np.zeros((n, self.text_len), dtype= 'uint8');
            traces = np.zeros((n, self.trace_size), dtype= self.channel_dtype);
            j = 0

            for i in idx:
                infile.seek(OurTraceLoader.HEADER_SIZE + self.row_len*i, 0)
                traces[j,:] = np.frombuffer(buffer=infile.read(self.trace_size* self.channel_dtype.itemsize), dtype= self.channel_dtype)
                plain_texts[j,:] = np.frombuffer(buffer=infile.read(self.text_len* plain_texts.itemsize), dtype=plain_texts.dtype)
                j = j + 1

        return traces, plain_texts
    
    def load_some_projected_traces(self, trace_indices, time_indices):
        if self.file_path is None:
            raise ValueError(OurTraceLoader.NO_FILE_MSG)

        trace_idx = np.array(trace_indices).reshape((len(trace_indices),1))
        self.validate_trace_indices(trace_idx)

        time_idx = np.array(time_indices)
        self.validate_time_indices(time_idx)
        
        trace_len = len(trace_indices)
        time_len = len(time_indices)
        
        with open(self.file_path,'rb') as infile:
            traces = np.zeros((trace_len, time_len), dtype= self.channel_dtype)
            plain_texts = np.zeros((trace_len, self.text_len), dtype= 'uint8')
            
            pos = OurTraceLoader.HEADER_SIZE + trace_idx*self.row_len + time_idx*self.channel_dtype.itemsize
            
            for i in range(pos.shape[0]):
                for j in range(pos.shape[1]):
                    infile.seek(pos[i][j], 0)
                    traces[i,j] =  np.frombuffer(buffer=infile.read(self.channel_dtype.itemsize), dtype= self.channel_dtype)
                
                infile.seek(OurTraceLoader.HEADER_SIZE+ self.row_len* trace_indices[i] + self.trace_size* self.channel_dtype.itemsize , 0)
                plain_texts[i,:] = np.frombuffer(buffer=infile.read(self.text_len* plain_texts.itemsize), dtype=plain_texts.dtype)
        
        return traces, plain_texts